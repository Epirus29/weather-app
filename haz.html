<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>HAZ — tiny platformer (stable collision)</title>
<style>
  :root{--bg:#0e1016;--panel:#121523;--text:#e9ecf6;--muted:#a3acc2;--accent:#77baff;--good:#3bd17f;--danger:#ff5d6c;}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  header{display:flex;justify-content:space-between;align-items:center;gap:10px;padding:10px 14px;background:linear-gradient(180deg,var(--panel),rgba(18,21,35,.9));border-bottom:1px solid #20263a;position:sticky;top:0;z-index:2}
  h1{font-size:16px;margin:0}
  .hud{display:flex;gap:12px;align-items:center;color:var(--muted);font-size:12px}
  .btn{appearance:none;border:1px solid #2a3452;background:#171b2b;color:#cfd7ee;border-radius:10px;padding:6px 10px;cursor:pointer}
  main{display:grid;place-items:center;padding:12px}
  canvas{background:linear-gradient(#1a2034,#0e1324);border:1px solid #20263a;border-radius:12px;max-width:100%;image-rendering:pixelated}
  footer{color:var(--muted);font-size:12px;text-align:center;margin:8px 0 16px}
  .kbd{border:1px solid #2a3452;background:#171b2b;border-radius:6px;padding:2px 6px}
</style>
</head>
<body>
<header>
  <h1>HAZ — tiny platformer</h1>
  <div class="hud">
    <span>Moves: <span class="kbd">←</span><span class="kbd">→</span> / <span class="kbd">A</span><span class="kbd">D</span></span>
    <span>Jump: <span class="kbd">Z</span> <span class="kbd">K</span> <span class="kbd">Space</span> <span class="kbd">W</span> <span class="kbd">↑</span></span>
    <span>Reset: <span class="kbd">R</span></span>
    <button id="resetBtn" class="btn">Reset</button>
  </div>
</header>

<main>
  <canvas id="game" width="960" height="540" aria-label="Haz platformer"></canvas>
</main>

<footer>
  Single-file HTML + inline JSON. Edit the <code>#level-json</code> block to change the map.
</footer>

<!-- LEVEL JSON (edit me!) -->
<script id="level-json" type="application/json">
{
  "tileSize": 32,
  "gravity": 2000,
  "moveSpeed": 220,
  "jumpVel": 640,
  "friction": 0.86,
  "width": 30,
  "height": 17,
  "playerStart": {"x": 2, "y": 12},
  "goal": {"x": 27, "y": 12},
  "enemies":[
    {"x": 13, "y": 12, "patrol":[12,16], "speed": 60},
    {"x": 20, "y": 8, "patrol":[19,23], "speed": 80}
  ],
  "tilesLegend": { "0":"empty", "1":"ground", "2":"platform", "3":"spike" },
  "tiles":[
    "000000000000000000000000000000",
    "000000000000000000000000000000",
    "000000000000000000000000000000",
    "000000000000000022220000000000",
    "000000000000000000000000000000",
    "000000000000000000000000000000",
    "000000000000000000000000000000",
    "000000000000000000002222000000",
    "000000000000000000000000000000",
    "000000000000000000000000000000",
    "000000000000000000000000000000",
    "000000000000000000000000000000",
    "111111111111110001111111111110",
    "100000000000010001000000000010",
    "100000000030010001000003000010",
    "100000000000011111000000000010",
    "111111111111111111111111111111"
  ]
}
</script>

<script>
(() => {
  // ---- helpers
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const EPS = 0.0001;

  // ---- read level JSON
  const level = JSON.parse(document.getElementById('level-json').textContent);
  const T = level.tileSize|0;
  const W = level.width|0, H = level.height|0;

  // ---- canvas / ctx
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // camera
  const cam = {x:0,y:0,w:canvas.width,h:canvas.height};

  // keyboard
  const keys = {};
  addEventListener('keydown',e=>{
    keys[e.key.toLowerCase()]=true;
    if([' ','arrowup','w','z','k'].includes(e.key.toLowerCase())) e.preventDefault();
  });
  addEventListener('keyup',e=>{keys[e.key.toLowerCase()]=false;});
  document.getElementById('resetBtn').onclick = ()=> reset();

  // tiles
  const rows = level.tiles.map(r=>r.split('').map(n=>+n));
  const inBounds = (tx,ty)=> tx>=0 && ty>=0 && tx<W && ty<H;
  const isGround = (tx,ty)=> inBounds(tx,ty) && rows[ty][tx]===1;
  const isPlatform = (tx,ty)=> inBounds(tx,ty) && rows[ty][tx]===2;
  const isSpike = (tx,ty)=> inBounds(tx,ty) && rows[ty][tx]===3;
  const isSolidH = (tx,ty)=> isGround(tx,ty); // horizontal ignores platforms
  const worldSolid = (tx,ty)=> !inBounds(tx,ty) || isGround(tx,ty); // outside = solid

  // entities
  const player = {x:0,y:0,vx:0,vy:0,w:18,h:26,onGround:false,dead:false,win:false,prevX:0,prevY:0,dir:1};
  const enemies = (level.enemies||[]).map(e=>({
    x:e.x*T + T/2, y:e.y*T + (T-18), w:18,h:18, vx:e.speed||60,
    patrol:[(e.patrol?.[0]??e.x)*T, (e.patrol?.[1]??e.x)*T], speed:e.speed||60
  }));
  const goal = {x: level.goal.x*T + T/2, y: level.goal.y*T + (T-32), w:20,h:32};

  function reset(){
    player.x = level.playerStart.x*T + T/2;
    player.y = level.playerStart.y*T - 2;
    player.vx = 0; player.vy = 0; player.onGround=false; player.dead=false; player.win=false;
    enemies.forEach(e=>{ e.x = (e.patrol[0]+e.patrol[1])/2; e.vx = Math.abs(e.speed); });
    cam.x = cam.y = 0;
  }
  reset();

  // physics
  const GRAV = level.gravity ?? 2000;
  const MOVE = level.moveSpeed ?? 220;
  const JUMP = level.jumpVel ?? 640;
  const FRICTION = level.friction ?? 0.86;
  const dtFixed = 1/120;

  // AABB helpers
  const rectsOverlap=(ax,ay,aw,ah,bx,by,bw,bh)=> ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by;

  // Horizontal collision against ground only
  function collideH(ent){
    const left = Math.floor((ent.x - ent.w/2)/T);
    const right = Math.floor((ent.x + ent.w/2)/T);
    const top = Math.floor((ent.y - ent.h/2)/T);
    const bottom = Math.floor((ent.y + ent.h/2)/T);

    if(ent.vx>0){
      // check tiles to the right
      const tx = right;
      for(let ty=top; ty<=bottom; ty++){
        if(worldSolid(tx,ty)){
          const tileLeft = tx*T;
          const overlap = (ent.x + ent.w/2) - tileLeft;
          if(overlap > 0){
            ent.x -= overlap + EPS;
            ent.vx = 0;
            break;
          }
        }
      }
    } else if(ent.vx<0){
      // check tiles to the left
      const tx = left;
      for(let ty=top; ty<=bottom; ty++){
        if(worldSolid(tx,ty)){
          const tileRight = (tx+1)*T;
          const overlap = tileRight - (ent.x - ent.w/2);
          if(overlap > 0){
            ent.x += overlap + EPS;
            ent.vx = 0;
            break;
          }
        }
      }
    }
  }

  // Vertical collision: ground (full) and platform (one-way when falling)
  function collideV(ent){
    ent.onGround = false;
    const left = Math.floor((ent.x - ent.w/2)/T);
    const right = Math.floor((ent.x + ent.w/2)/T);
    const top = Math.floor((ent.y - ent.h/2)/T);
    const bottom = Math.floor((ent.y + ent.h/2)/T);

    if(ent.vy>0){
      // moving down
      const ty = bottom;
      const prevFeet = (ent.prevY + ent.h/2);
      for(let tx=left; tx<=right; tx++){
        // full solids
        if(worldSolid(tx,ty)){
          const tileTop = ty*T;
          const overlap = (ent.y + ent.h/2) - tileTop;
          if(overlap>0){
            ent.y -= overlap + EPS;
            ent.vy = 0;
            ent.onGround = true;
          }
        } else if(isPlatform(tx,ty)){
          // platform only if previously above and now intersecting
          const tileTop = ty*T;
          const feet = ent.y + ent.h/2;
          if(prevFeet <= tileTop + 1 && feet >= tileTop){
            ent.y = tileTop - ent.h/2 - EPS;
            ent.vy = 0;
            ent.onGround = true;
          }
        }
      }
    } else if(ent.vy<0){
      // moving up: collide with solid ceilings (not platforms)
      const ty = top;
      for(let tx=left; tx<=right; tx++){
        if(worldSolid(tx,ty)){
          const tileBottom = (ty+1)*T;
          const overlap = tileBottom - (ent.y - ent.h/2);
          if(overlap>0){
            ent.y += overlap + EPS;
            ent.vy = 0;
          }
        }
      }
    }

    // spikes (check around feet & torso)
    for(let ty=top; ty<=bottom; ty++){
      for(let tx=left; tx<=right; tx++){
        if(isSpike(tx,ty)){
          const sx=tx*T+4, sy=ty*T+8, sw=T-8, sh=T-8;
          if(rectsOverlap(ent.x-ent.w/2, ent.y-ent.h/2, ent.w, ent.h, sx,sy,sw,sh)){
            kill();
            return;
          }
        }
      }
    }
  }

  function kill(){ player.dead=true; setTimeout(reset, 700); }

  // loop
  let acc=0, last=performance.now();
  function frame(now){
    const dt = Math.min(0.05,(now-last)/1000); last=now; acc+=dt;
    while(acc>=dtFixed){ update(dtFixed); acc-=dtFixed; }
    draw();
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  function update(dt){
    if(keys['r']) reset();

    // remember previous pos for platform logic
    player.prevX = player.x; player.prevY = player.y;

    // input
    const left = keys['arrowleft']||keys['a'];
    const right = keys['arrowright']||keys['d'];
    const jump = keys[' ']||keys['arrowup']||keys['w']||keys['z']||keys['k'];

    // horizontal accel (arcade style)
    if(left) player.vx = -MOVE;
    else if(right) player.vx = MOVE;
    else player.vx *= FRICTION;
    if(Math.abs(player.vx)<0.05) player.vx=0;

    if(right) player.dir=1; else if(left) player.dir=-1;

    // gravity
    player.vy += GRAV*dt;
    // jump
    if(jump && player.onGround){
      player.vy = -JUMP;
      player.onGround=false;
    }

    // integrate X first, then collide horizontally
    player.x += player.vx*dt;
    collideH(player);

    // integrate Y, then collide vertically (incl. platforms)
    player.y += player.vy*dt;
    collideV(player);

    // enemies patrol + collide (simple)
    enemies.forEach(e=>{
      e.x += Math.sign(e.vx) * Math.abs(e.vx) * dt;
      if(e.x < e.patrol[0]+9){ e.x = e.patrol[0]+9; e.vx = Math.abs(e.speed); }
      if(e.x > e.patrol[1]-9){ e.x = e.patrol[1]-9; e.vx = -Math.abs(e.speed); }
      if(rect
